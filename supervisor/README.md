# Supervisor - Interfaces Segregadas para Auditor√≠a y Trazabilidad

**Versi√≥n**: 1.0.0
**Autor**: Victor Valotto
**Objetivo**: Demostraci√≥n de ISP (Interface Segregation Principle) correctamente aplicado

## üìã Descripci√≥n

Paquete que proporciona **interfaces segregadas** para auditor√≠a y trazabilidad, demostrando la aplicaci√≥n correcta del **Interface Segregation Principle (ISP)**.

Este paquete es la **soluci√≥n** a la violaci√≥n ISP presente en `BaseRepositorio`, donde se obligaba a todos los repositorios a implementar m√©todos de auditor√≠a y trazabilidad innecesarios.

## üéØ Problema que Resuelve

### ‚ùå Antes: Violaci√≥n ISP en BaseRepositorio

```python
class BaseRepositorio(ABC):
    @abstractmethod
    def guardar(self, entidad): pass        # ‚úÖ Todos lo necesitan

    @abstractmethod
    def obtener(self, id_entidad): pass     # ‚úÖ Todos lo necesitan

    @abstractmethod
    def auditar(self, entidad, auditoria): pass    # ‚ö†Ô∏è Solo se√±ales

    @abstractmethod
    def trazar(self, entidad, accion, mensaje): pass  # ‚ö†Ô∏è Solo se√±ales

# Consecuencia: RepositorioUsuario forzado a implementar m√©todos innecesarios
class RepositorioUsuario(BaseRepositorio):
    def auditar(self, entidad, auditoria):
        raise NotImplementedError("No soportado")  # ‚ùå Stub innecesario
```

### ‚úÖ Despu√©s: ISP Correctamente Aplicado

```python
# Interfaces segregadas en paquete supervisor
from supervisor import BaseAuditor, BaseTrazador

# Interfaz b√°sica - TODOS la necesitan
class IRepositorioBasico(ABC):
    def guardar(self, entidad): pass
    def obtener(self, id_entidad): pass

# Composici√≥n seg√∫n necesidades
class RepositorioSenial(IRepositorioBasico):
    def __init__(self, contexto, auditor: BaseAuditor, trazador: BaseTrazador):
        self._contexto = contexto
        self._auditor = auditor      # ‚úÖ Composici√≥n
        self._trazador = trazador    # ‚úÖ Composici√≥n

class RepositorioUsuario(IRepositorioBasico):
    """Solo persistencia - NO auditor√≠a ni trazabilidad"""
    # ‚úÖ Sin m√©todos innecesarios
```

## üèóÔ∏è Componentes

### `BaseAuditor` - Interfaz de Auditor√≠a

Interfaz segregada que define **solo** la responsabilidad de auditor√≠a.

```python
from abc import ABCMeta, abstractmethod
from typing import Any

class BaseAuditor(metaclass=ABCMeta):
    """
    Abstracci√≥n para auditores.

    Aplicaci√≥n de ISP: interfaz espec√≠fica SOLO para auditor√≠a.
    """

    @abstractmethod
    def auditar(self, entidad: Any, auditoria: str) -> None:
        """
        Registra un evento de auditor√≠a sobre una entidad.

        :param entidad: Entidad sobre la cual se registra la auditor√≠a
        :param auditoria: Descripci√≥n del evento de auditor√≠a
        """
        pass
```

### `BaseTrazador` - Interfaz de Trazabilidad

Interfaz segregada que define **solo** la responsabilidad de trazabilidad.

```python
from abc import ABCMeta, abstractmethod
from typing import Any

class BaseTrazador(metaclass=ABCMeta):
    """
    Abstracci√≥n para trazadores.

    Aplicaci√≥n de ISP: interfaz espec√≠fica SOLO para trazabilidad.
    """

    @abstractmethod
    def trazar(self, entidad: Any, accion: str, mensaje: str) -> None:
        """
        Registra una traza de acci√≥n sobre una entidad.

        :param entidad: Entidad sobre la cual se registra la traza
        :param accion: Tipo de acci√≥n realizada
        :param mensaje: Mensaje descriptivo de la traza
        """
        pass
```

## üöÄ Instalaci√≥n

```bash
pip install -e supervisor/
```

## üíª Uso

### Importar Abstracciones

```python
from supervisor import BaseAuditor, BaseTrazador
```

### Implementar Auditores Concretos

```python
import datetime

class AuditorArchivo(BaseAuditor):
    """Auditor que escribe en archivo"""

    def __init__(self, ruta_archivo='auditor.log'):
        self._ruta_archivo = ruta_archivo

    def auditar(self, entidad, auditoria):
        with open(self._ruta_archivo, 'a') as f:
            f.write(f'------->\n')
            f.write(f'Entidad ID: {entidad.id}\n')
            f.write(f'Fecha: {datetime.datetime.now()}\n')
            f.write(f'Auditor√≠a: {auditoria}\n\n')
```

### Implementar Trazadores Concretos

```python
import datetime

class TrazadorArchivo(BaseTrazador):
    """Trazador que escribe en archivo"""

    def __init__(self, ruta_archivo='logger.log'):
        self._ruta_archivo = ruta_archivo

    def trazar(self, entidad, accion, mensaje):
        with open(self._ruta_archivo, 'a') as f:
            f.write(f'------->\n')
            f.write(f'Acci√≥n: {accion}\n')
            f.write(f'Entidad ID: {entidad.id}\n')
            f.write(f'Fecha: {datetime.datetime.now()}\n')
            f.write(f'Mensaje: {mensaje}\n\n')
```

### Usar en Repositorios (Composici√≥n)

```python
from supervisor import BaseAuditor, BaseTrazador

class RepositorioSenial:
    """Repositorio con auditor√≠a y trazabilidad"""

    def __init__(self, contexto, auditor: BaseAuditor, trazador: BaseTrazador):
        self._contexto = contexto
        self._auditor = auditor
        self._trazador = trazador

    def guardar(self, senial):
        # Guardar se√±al
        self._contexto.persistir(senial, str(senial.id))

        # Auditar operaci√≥n
        self._auditor.auditar(senial, "Se√±al guardada correctamente")

        # Trazar operaci√≥n
        self._trazador.trazar(senial, "PERSISTENCIA", "Guardado completado")

    def obtener(self, id_senial):
        return self._contexto.recuperar(id_senial)

class RepositorioUsuario:
    """Repositorio simple - SIN auditor√≠a ni trazabilidad"""

    def __init__(self, contexto):
        self._contexto = contexto  # ‚úÖ Solo lo necesario

    def guardar(self, usuario):
        self._contexto.persistir(usuario, str(usuario.id))

    def obtener(self, id_usuario):
        return self._contexto.recuperar(id_usuario)

    # ‚úÖ NO hay m√©todos auditar() ni trazar() innecesarios
```

## üìä Comparaci√≥n: Antes vs Despu√©s

| Aspecto | Violaci√≥n ISP | ISP Correcto |
|---------|--------------|--------------|
| **BaseRepositorio** | 4 m√©todos obligatorios | Interfaces segregadas |
| **RepositorioUsuario** | Stubs con `NotImplementedError` | Solo m√©todos necesarios |
| **RepositorioSenial** | M√©todos en la clase | Composici√≥n con auditor/trazador |
| **Reutilizaci√≥n** | Auditor√≠a acoplada | Auditor/Trazador reutilizable |
| **Flexibilidad** | Cambiar = modificar clase | Cambiar = inyectar implementaci√≥n |
| **Testabilidad** | Dif√≠cil mockear | F√°cil inyectar mocks |

## ‚úÖ Principios SOLID Demostrados

### 1. ISP (Interface Segregation Principle) ‚≠ê
**"Los clientes no deber√≠an verse obligados a depender de interfaces que no utilizan"**

- ‚úÖ `BaseAuditor` y `BaseTrazador` son interfaces **segregadas**
- ‚úÖ Cada interfaz tiene **una responsabilidad espec√≠fica**
- ‚úÖ `RepositorioUsuario` no depende de auditor√≠a/trazabilidad
- ‚úÖ `RepositorioSenial` solo depende de lo que usa

### 2. SRP (Single Responsibility Principle)
- `BaseAuditor`: Una responsabilidad - Auditor√≠a
- `BaseTrazador`: Una responsabilidad - Trazabilidad

### 3. DIP (Dependency Inversion Principle)
- Repositorios dependen de **abstracciones** (`BaseAuditor`, `BaseTrazador`)
- Implementaciones concretas se **inyectan** v√≠a constructor

### 4. OCP (Open/Closed Principle)
- F√°cil agregar nuevas implementaciones sin modificar interfaces
- Extensible: `AuditorConsola`, `TrazadorBD`, `AuditorCloud`, etc.

### 5. LSP (Liskov Substitution Principle)
- Cualquier implementaci√≥n de `BaseAuditor` es intercambiable
- Cualquier implementaci√≥n de `BaseTrazador` es intercambiable

## üéì Valor Did√°ctico

### Lecci√≥n 1: Segregaci√≥n de Interfaces
**Antes**: Una interfaz "gorda" con m√©todos que no todos necesitan
**Despu√©s**: Interfaces peque√±as y espec√≠ficas

### Lecci√≥n 2: Composici√≥n sobre Herencia
**Antes**: Herencia forzada de m√©todos innecesarios
**Despu√©s**: Composici√≥n flexible seg√∫n necesidades

### Lecci√≥n 3: Dependencias Opcionales
**Antes**: Todos dependen de todo
**Despu√©s**: Cada cliente depende solo de lo que usa

## üîó Integraci√≥n con el Proyecto

### Estructura del Proyecto

```
Senial_SOLID_IS/
‚îú‚îÄ‚îÄ supervisor/              # ‚úÖ Interfaces segregadas (ISP)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ auditor.py          # BaseAuditor
‚îÇ   ‚îú‚îÄ‚îÄ trazador.py         # BaseTrazador
‚îÇ   ‚îú‚îÄ‚îÄ setup.py
‚îÇ   ‚îî‚îÄ‚îÄ README.md           # Este archivo
‚îÇ
‚îú‚îÄ‚îÄ persistidor_senial/      # Repositorios que USAN supervisor
‚îÇ   ‚îú‚îÄ‚îÄ repositorio.py      # IRepositorioBasico + composici√≥n
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îî‚îÄ‚îÄ ...
```

### Flujo de Correcci√≥n ISP

1. **Crear paquete `supervisor`** con interfaces segregadas ‚úÖ
2. **Refactorizar `repositorio.py`**:
   - Crear `IRepositorioBasico` (guardar, obtener)
   - Crear `IRepositorioAuditable` (opcional)
3. **Modificar `RepositorioSenial`**:
   - Recibir `auditor` y `trazador` por composici√≥n
4. **Simplificar `RepositorioUsuario`**:
   - Solo implementar `IRepositorioBasico`
   - Eliminar stubs de auditar/trazar

## üìö Referencias

### Documentaci√≥n del Proyecto
- **Violaci√≥n ISP**: `../docs/PATRON REPOSITORY EN PERSISTENCIA.md`
- **README Principal**: `../README.md`
- **Demo Violaci√≥n**: `../demo_violacion_isp.py`

### Patr√≥n ISP
> **Martin, Robert C.** - "Agile Software Development: Principles, Patterns, and Practices"
>
> *"The Interface Segregation Principle states that clients should not be forced to depend upon interfaces that they do not use."*

## üîÑ Pr√≥ximos Pasos

### Implementaciones Concretas Sugeridas

```python
# En persistidor_senial o m√≥dulo separado
from supervisor import BaseAuditor, BaseTrazador

class AuditorArchivo(BaseAuditor):
    """Implementaci√≥n que escribe en archivo"""
    # ... implementaci√≥n ...

class TrazadorArchivo(BaseTrazador):
    """Implementaci√≥n que escribe en archivo"""
    # ... implementaci√≥n ...

class AuditorNulo(BaseAuditor):
    """Null Object Pattern - Sin efecto"""
    def auditar(self, entidad, auditoria):
        pass  # No hace nada
```

### Configurador Actualizado

```python
from supervisor import BaseAuditor, BaseTrazador

class Configurador:
    @staticmethod
    def crear_auditor() -> BaseAuditor:
        return AuditorArchivo('./logs/auditor.log')

    @staticmethod
    def crear_trazador() -> BaseTrazador:
        return TrazadorArchivo('./logs/logger.log')

    @staticmethod
    def crear_repositorio_senial():
        contexto = ContextoArchivo('./datos/adquisicion')
        auditor = Configurador.crear_auditor()
        trazador = Configurador.crear_trazador()
        return RepositorioSenial(contexto, auditor, trazador)
```

## üí° Conclusi√≥n

El paquete `supervisor` demuestra c√≥mo **segregar interfaces** de forma correcta:

‚úÖ **Interfaces peque√±as y cohesivas**
‚úÖ **Clientes dependen solo de lo necesario**
‚úÖ **Composici√≥n flexible en lugar de herencia r√≠gida**
‚úÖ **C√≥digo m√°s testeable y mantenible**

Esta es la **correcci√≥n completa** de la violaci√≥n ISP identificada en el proyecto, aplicando el principio de forma pr√°ctica y did√°ctica.

---

**üìñ Paquete Did√°ctico - Victor Valotto**
**üéØ Objetivo**: Demostraci√≥n de ISP correctamente aplicado
**üîÑ Estado v1.0.0**: Interfaces segregadas - Base para correcci√≥n ISP en repositorios
